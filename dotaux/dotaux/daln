#! /bin/sh
# Generated from /home/pat/dotaux/pkgs/dotaux/bin/daln.as by GNU Autoconf 2.68.
## -------------------- ##
## M4sh Initialization. ##
## -------------------- ##

# Be more Bourne compatible
DUALCASE=1; export DUALCASE # for MKS sh
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in #(
  *posix*) :
    set -o posix ;; #(
  *) :
     ;;
esac
fi


as_nl='
'
export as_nl
# Printing a long string crashes Solaris 7 /usr/bin/printf.
as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
# Prefer a ksh shell builtin over an external printf program on Solaris,
# but without wasting forks for bash or zsh.
if test -z "$BASH_VERSION$ZSH_VERSION" \
    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='print -r --'
  as_echo_n='print -rn --'
elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='printf %s\n'
  as_echo_n='printf %s'
else
  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
    as_echo_n='/usr/ucb/echo -n'
  else
    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
    as_echo_n_body='eval
      arg=$1;
      case $arg in #(
      *"$as_nl"*)
	expr "X$arg" : "X\\(.*\\)$as_nl";
	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
      esac;
      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
    '
    export as_echo_n_body
    as_echo_n='sh -c $as_echo_n_body as_echo'
  fi
  export as_echo_body
  as_echo='sh -c $as_echo_body as_echo'
fi

# The user is always right.
if test "${PATH_SEPARATOR+set}" != set; then
  PATH_SEPARATOR=:
  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
      PATH_SEPARATOR=';'
  }
fi


# IFS
# We need space, tab and new line, in precisely that order.  Quoting is
# there to prevent editors from complaining about space-tab.
# (If _AS_PATH_WALK were called with IFS unset, it would disable word
# splitting by setting IFS to empty value.)
IFS=" ""	$as_nl"

# Find who we are.  Look in the path if we contain no directory separator.
as_myself=
case $0 in #((
  *[\\/]* ) as_myself=$0 ;;
  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
  done
IFS=$as_save_IFS

     ;;
esac
# We did not find ourselves, most probably we were run as `sh COMMAND'
# in which case we are not to be found in the path.
if test "x$as_myself" = x; then
  as_myself=$0
fi
if test ! -f "$as_myself"; then
  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
  exit 1
fi

# Unset variables that we do not need and which cause bugs (e.g. in
# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
# suppresses any "Segmentation fault" message there.  '((' could
# trigger a bug in pdksh 5.2.14.
for as_var in BASH_ENV ENV MAIL MAILPATH
do eval test x\${$as_var+set} = xset \
  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
done
PS1='$ '
PS2='> '
PS4='+ '

# NLS nuisances.
LC_ALL=C
export LC_ALL
LANGUAGE=C
export LANGUAGE

# CDPATH.
(unset CDPATH) >/dev/null 2>&1 && unset CDPATH

if test "x$CONFIG_SHELL" = x; then
  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '\${1+\"\$@\"}'='\"\$@\"'
  setopt NO_GLOB_SUBST
else
  case \`(set -o) 2>/dev/null\` in #(
  *posix*) :
    set -o posix ;; #(
  *) :
     ;;
esac
fi
"
  as_required="as_fn_return () { (exit \$1); }
as_fn_success () { as_fn_return 0; }
as_fn_failure () { as_fn_return 1; }
as_fn_ret_success () { return 0; }
as_fn_ret_failure () { return 1; }

exitcode=0
as_fn_success || { exitcode=1; echo as_fn_success failed.; }
as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :

else
  exitcode=1; echo positional parameters were not saved.
fi
test x\$exitcode = x0 || exit 1"
  as_suggested="test \$(( 1 + 1 )) = 2 || exit 1"
  if (eval "$as_required") 2>/dev/null; then :
  as_have_required=yes
else
  as_have_required=no
fi
  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :

else
  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
as_found=false
for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  as_found=:
  case $as_dir in #(
	 /*)
	   for as_base in sh bash ksh sh5; do
	     # Try only shells that exist, to save several forks.
	     as_shell=$as_dir/$as_base
	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
  CONFIG_SHELL=$as_shell as_have_required=yes
		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
  break 2
fi
fi
	   done;;
       esac
  as_found=false
done
$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
  CONFIG_SHELL=$SHELL as_have_required=yes
fi; }
IFS=$as_save_IFS


      if test "x$CONFIG_SHELL" != x; then :
  # We cannot yet assume a decent shell, so we have to provide a
	# neutralization value for shells without unset; and this also
	# works around shells that cannot unset nonexistent variables.
	# Preserve -v and -x to the replacement shell.
	BASH_ENV=/dev/null
	ENV=/dev/null
	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
	export CONFIG_SHELL
	case $- in # ((((
	  *v*x* | *x*v* ) as_opts=-vx ;;
	  *v* ) as_opts=-v ;;
	  *x* ) as_opts=-x ;;
	  * ) as_opts= ;;
	esac
	exec "$CONFIG_SHELL" $as_opts "$as_myself" ${1+"$@"}
fi

    if test x$as_have_required = xno; then :
  $as_echo "$0: This script requires a shell more modern than all"
  $as_echo "$0: the shells that I found on your system."
  if test x${ZSH_VERSION+set} = xset ; then
    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
  else
    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
$0: including any error possibly output before this
$0: message. Then install a modern shell, or manually run
$0: the script under such a shell if you do have one."
  fi
  exit 1
fi
fi
fi
SHELL=${CONFIG_SHELL-/bin/sh}
export SHELL
# Unset more variables known to interfere with behavior of common tools.
CLICOLOR_FORCE= GREP_OPTIONS=
unset CLICOLOR_FORCE GREP_OPTIONS

## --------------------- ##
## M4sh Shell Functions. ##
## --------------------- ##
# as_fn_unset VAR
# ---------------
# Portably unset VAR.
as_fn_unset ()
{
  { eval $1=; unset $1;}
}
as_unset=as_fn_unset

# as_fn_mkdir_p
# -------------
# Create "$as_dir" as a directory, including parents if necessary.
as_fn_mkdir_p ()
{

  case $as_dir in #(
  -*) as_dir=./$as_dir;;
  esac
  test -d "$as_dir" || eval $as_mkdir_p || {
    as_dirs=
    while :; do
      case $as_dir in #(
      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
      *) as_qdir=$as_dir;;
      esac
      as_dirs="'$as_qdir' $as_dirs"
      as_dir=`$as_dirname -- "$as_dir" ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_dir" : 'X\(//\)[^/]' \| \
	 X"$as_dir" : 'X\(//\)$' \| \
	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
      test -d "$as_dir" && break
    done
    test -z "$as_dirs" || eval "mkdir $as_dirs"
  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"


} # as_fn_mkdir_p

# as_fn_set_status STATUS
# -----------------------
# Set $? to STATUS, without forking.
as_fn_set_status ()
{
  return $1
} # as_fn_set_status

# as_fn_exit STATUS
# -----------------
# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
as_fn_exit ()
{
  set +e
  as_fn_set_status $1
  exit $1
} # as_fn_exit
# as_fn_arith ARG...
# ------------------
# Perform arithmetic evaluation on the ARGs, and store the result in the
# global $as_val. Take advantage of shells that can avoid forks. The arguments
# must be portable across $(()) and expr.
if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
  eval 'as_fn_arith ()
  {
    as_val=$(( $* ))
  }'
else
  as_fn_arith ()
  {
    as_val=`expr "$@" || test $? -eq 1`
  }
fi # as_fn_arith


# as_fn_error STATUS ERROR
# ------------------------
# Output "`basename $0`: error: ERROR" to stderr. Then exit the script with
# STATUS, using 1 if that was 0.
as_fn_error ()
{
  as_status=$1; test $as_status -eq 0 && as_status=1
  $as_echo "$as_me: error: $2" >&2
  as_fn_exit $as_status
} # as_fn_error

if expr a : '\(a\)' >/dev/null 2>&1 &&
   test "X`expr 00001 : '.*\(...\)'`" = X001; then
  as_expr=expr
else
  as_expr=false
fi

if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
  as_dirname=dirname
else
  as_dirname=false
fi

if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
  as_basename=basename
else
  as_basename=false
fi

as_me=`$as_basename -- "$0" ||
$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
	 X"$0" : 'X\(//\)$' \| \
	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X/"$0" |
    sed '/^.*\/\([^/][^/]*\)\/*$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`

if mkdir -p . 2>/dev/null; then
  as_mkdir_p='mkdir -p "$as_dir"'
else
  test -d ./-p && rmdir ./-p
  as_mkdir_p=false
fi

# Avoid depending upon Character Ranges.
as_cr_letters='abcdefghijklmnopqrstuvwxyz'
as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
as_cr_Letters=$as_cr_letters$as_cr_LETTERS
as_cr_digits='0123456789'
as_cr_alnum=$as_cr_Letters$as_cr_digits

# Sed expression to map a string onto a valid variable name.
as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"


rm -f conf$$ conf$$.exe conf$$.file
if test -d conf$$.dir; then
  rm -f conf$$.dir/conf$$.file
else
  rm -f conf$$.dir
  mkdir conf$$.dir 2>/dev/null
fi
if (echo >conf$$.file) 2>/dev/null; then
  if ln -s conf$$.file conf$$ 2>/dev/null; then
    as_ln_s='ln -s'
    # ... but there are two gotchas:
    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
    # In both cases, we have to default to `cp -p'.
    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
      as_ln_s='cp -p'
  elif ln conf$$.file conf$$ 2>/dev/null; then
    as_ln_s=ln
  else
    as_ln_s='cp -p'
  fi
else
  as_ln_s='cp -p'
fi
rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
rmdir conf$$.dir 2>/dev/null

## -------------------- ##
## Main body of script. ##
## -------------------- ##


# Prepare shell functions from dotAux lib.

# ------------------
# Defined function for dirname and basename
# das_fn_dirname PATH
# -------------------
# Our version of dirname.
das_fn_dirname()
{
	$as_dirname -- $1 ||
$as_expr X$1 : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X$1 : 'X\(//\)[^/]' \| \
	 X$1 : 'X\(//\)$' \| \
	 X$1 : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X$1 |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'
}
# das_fn_dirname
# das_fn_basename PATH
# --------------------
# Our version of basename.
das_fn_basename()
{
	$as_basename -- $1 ||
$as_expr X/$1 : '.*/\([^/][^/]*\)/*$' \| \
	 X$1 : 'X\(//\)$' \| \
	 X$1 : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X/$1 |
    sed '/^.*\/\([^/][^/]*\)\/*$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'
}
# das_fn_basename

# ------------------
# das_fn_loc_in_path NAME
# -----------------------
# dnl Locate an executable in PATH.
das_fn_loc_in_path()
{
(#subshell local vars
	# as_dir as built-in var
	as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.

		f="$as_dir/$1"

	if test -f "$f"; then :

			$as_echo "$as_dir/$1"
			break 2

fi


  done
IFS=$as_save_IFS

)
}
#das_fn_loc_in_path

# ------------------
# das_fn_mydir
# ------------
# Find out my dir. case 1: ./foo or ~/foo case 2: /foo case 3: foo case 4: sh
# foo
das_fn_mydir()
{

(#subshell local vars
	mydir=`das_fn_dirname "$as_myself"`
	# check if case 3 or 4
	if ${mydir:+false} :; then :

		# check if case 3
		try=`das_fn_loc_in_path "$as_me"`
		if ${try:+false} :; then :

			# case 4
			mydir=`pwd`

else

			# case 3
			mydir=`das_fn_dirname "$try"`

fi
		# AS_VAR_IF try

fi
	# AS_VAR_IF mydir

	$as_echo "$mydir"
)
}
#das_fn_mydir

# ------------------
# das_fn_myself
# -------------
# Private. Internal use only
das_fn_myself()
{
(#subshell local vars
	bname="$as_me"
	dname=`das_fn_mydir`

	# cd cannot use DAS_EXEC or $() or ` `
	cd $dname
	tmp=`pwd`/$bname
	# Need check if is a link
	while :
	do
		if test -L $tmp; then :
  tmp=`readlink "$tmp"`
else

			# I'm now the final original
			bname=`das_fn_basename "$tmp"`
			dname=`das_fn_dirname "$tmp"`
			# cannot test -d $dname

	if ${dname:+false} :; then :

else

				cd $dname
				dname=`pwd`

fi

			break

fi
		# AS_IF
	done
	$as_echo "$dname/$bname"
)
}
# das_fn_myself

# ------------------
# das_fn_locself
# --------------
# dnl Locate a script, provide path name. Per a script /bin/test in which
# DAS_LOCSELF got expanded, it emits /bin/test. Another case is if you have a
# script /usr/sbin/foo, and had performed symbol link (and renamed) to
# /bin/bar, and /bin/bar was invoked, this macro emits /usr/sbin/foo, say the
# original. NOTE: Maybe can't use BASH_SOURCE in m4sh if its BINSH is not
# /bin/bash but /bin/sh.
das_fn_locself()
{

	das_pwd=`pwd`
	das_myself=`das_fn_myself`
	# restore pwd
	cd $das_pwd
	das_me=`das_fn_basename "$das_myself"`
	das_myloc=`das_fn_dirname "$das_myself"`
	$as_echo "$das_myself"
}
#das_fn_locself

# -------------------
#AS_FUNCTION_DESCRIBE([das_fn_exec], [cmd], [Exec cmd])
#das_fn_exec()
#{
#
#}

# -------------------
# das_fn_chkdir path
# ------------------
# Test and create a dir if not exist yet.
das_fn_chkdir()
{
(#subshell local vars
	dname=$1

	if test -f "$dname"; then :

		as_fn_error $? "\"$dname\" exists as a file! Exit ..."

fi

	# HAS_FILE

	if ! test -d "$dname"; then :

		as_dir=$dname; as_fn_mkdir_p

fi

	# NO_DIR

	if ! test -d "$dname"; then :

		as_fn_error $? "\"$dname\" required but seems failed to create it. Exit..."

fi

	# NO_DIR
)
}
# das_fn_chkdir

# -------------------------------------
# das_fn_str_trim String
# ----------------------
# Trim heading and tailing space, tab, etc
das_fn_str_trim()
{
(#subshell local vars
	str="$1"
	$as_echo "$str" | sed "s/^[ \t]*//g;s/[ \t\r\n]*$//g"
)
}

# -------------------------------------
# das_fn_str_parse_value String, Key, Delim
# -----------------------------------------
# Parse value against to a key from a string in cases Key=Value, Key:=Value,
# Key = Value, Key := Value, ... now also support delim e.g. Key: Value, and
# as default scenario.
#Return the Value
das_fn_str_parse_value()
{
(#subshell local vars
	str="$1"
	key="$2"
	delim="$3"
	if ${delim:+false} :; then :

		# fall back to default delim ':'
		delim=:

fi
	str=`		$as_echo "$1" | sed -n "s/^""$2"" \{0,1\}:\{0,1\}""$3"":\{0,1\} \{0,1\}\(.*\)/\1/p" `
	das_fn_str_trim "$str"
)
}
# das_fn_str_parse_value

# -------------------------------------
# das_fn_file_parse_value File, Key, Delim
# ----------------------------------------
# Parse value against to a key from a string.
#Return the Value
das_fn_file_parse_value()
{
(#subshell local vars
	file="$1"
	key="$2"
	delim="$3"
	val=

	if ${delim:+false} :; then :

		# fall back to default delim ':'
		delim=:

fi
	val=`			sed -n "/^""$2"" \{0,1\}:\{0,1\}""$3"":\{0,1\} \{0,1\}/ {p;q;}" "$1" `
	das_fn_str_parse_value "$val" "$key" "$delim"
)
}
# das_fn_file_parse_value

# das_fn_dir_file_list Path, Pattern, Need-Sort
# ---------------------------------------------
# Get file list of a folder. Usage: list=$(das_fn_dir_file_list "." "*.txt") #
# no sort list=$(das_fn_dir_file_list "." "*.txt" "1") # list sorted now you
# can use them like for f in $list; do echo "==$f" done
das_fn_dir_file_list()
{
(#subshell local vars
	path=$1
	pat="$2"
	sorted=$3
	list=

	# cannot use list=(`find "$path" -name "$pat"`)
	list=`find "$path" -name "$pat"`
	# cannot use list=`ls $path/"$pat"`
	if ${sorted:+false} :; then :

		list=`$as_echo "$list" | sort`

fi
	# AS_VAR_IF
	$as_echo "$list"
)
}
# das_fn_dir_file_list

# --------------------------
# das_fn_str_field_count STR, Delim
# ---------------------------------
# Get cound of fields in the string STR. Per "4:3:2:1", the delimiter is ":",
# count is 4. Defalt delim is space ' '.
das_fn_str_field_count()
{
(#subshell local vars
	str="$1"
	delim="$2"
	if ${delim:+false} :; then :

		# fall back to default delim ' '
		delim=

fi

	$as_echo "$str" | awk -F '"$delim"' '{print NF}'
)
}
# das_fn_str_field_count

# --------------------------
# das_fn_str_get_field STR, INDEX, Delim
# --------------------------------------
# Get a specific field in the string STR. Per "4:3:2:1", index starts from 1;
# get_field(2) returns "3". Defalt delim is space ' '.
das_fn_str_get_field()
{
(#subshell local vars
	str="$1"
	index="$2"
	delim="$3"
	if ${delim:+false} :; then :

		# fall back to default delim ' '
		delim=

fi

	$as_echo "$str" | awk -F '"$delim"' '{print $'"$index"'}'
)
}
# das_fn_str_get_field

# -------------------
# das_fn_chkctx
# -------------
# Check execution context
das_fn_chkctx()
{
	das_ctx=0
	das_ctx=1


	# FIXME if not gcc/g++, see AC_PROG_CC code for reference
	if test "x$das_ctx" = x3; then :


	if test x"$CC" = x; then :
  CC=gcc
fi


	if test x"$CXX" = x; then :
  CXX=g++
fi


fi
}
# das_fn_chkctx

# -------------------
das_fn_chkctx




	# hope nobody else uses das_def_*

	das_def_myversion="0.1.0.4"


# usage
# -----
# Help info of myself.
usage()
{
	$as_echo "$as_me: Usage and optinos:" >&1
	$as_echo "$as_me:  <link> <pattern>
This utility links a source (file or folder) to current location as <link>
  link                    Source and Dest (the link) name.
  pattern                 Source path pattern.
  -h|--help               Display help info
  -V|--version            Display version info
	" >&1
	# AS_MESSAGE
}


	# hope nobody else uses das_def_*

	das_def_opts="`getopt -o hV -l help -l version -- "$@"`"


	# hope nobody else uses das_def_*

	das_def_code="$?"


	if test x"$das_def_code" != x"0"; then :

	usage
	as_fn_error $? "Incorrect argument list"

fi





eval set -- "$das_def_opts"

while :
do
	case $1 in #(
  -h|--help) :
    usage; as_fn_exit $? ;; #(
  -V|--version) :
    $as_echo "$das_def_myversion"; as_fn_exit $? ;; #(
  --) :
    shift; break ;; #(
  *) :

			usage
			as_fn_error $? "Unknown options: $@"

	 ;;
esac
	# AS_CASE
done


	das_fn_locself >/dev/null
	$as_echo "I'm $das_me (v$das_def_myversion) on $das_myloc, working on $das_pwd!"


if test $# -lt 2; then :

	usage
	as_fn_error $? "Incorrect arguments: $@"

fi

# do_check list, pattern
# ----------------------
# Check each file to see if match.
do_check()
{
(#subshell local vars
	list="$1"
	pat="$2"
	found=

	for t in $list
do :

		if ${pat:+false} :; then :

			$as_echo "Found $t, link it"
			$as_ln_s $t `das_fn_basename "$t"`
			break

else

			found=`	$as_echo "$t" | sed -e "s/\//_/g" `
			found=`	$as_echo "$found" | sed -n "/$pat/ p" `

	if test x"$found" != x; then :

				$as_echo "Found $t, link it"
				$as_ln_s $t `das_fn_basename "$t"`
				break

fi

			# DAS_HAS_STR

fi
		# AS_VAR_IF

done
	# AS_FOR
)
}

(#subshell local vars
src=$1
pat="$2"
spath=..
list=
timeout=20

$as_echo "$as_me: Searching for \"$src\", matching \"$pat\"..." >&1
pat=`	$as_echo "$pat" | sed -e "s/\//_/g" `
while :
do
	$as_echo "$as_me: Search on path \"$spath\"" >&1
	list=`das_fn_dir_file_list "$spath" "$src"`

	das_def_opts=`do_check "$list" "$pat"`

	if test x"$das_def_opts" != x; then :

		$as_echo "$as_me: $das_def_opts" >&1
		break

fi

	if test "x$timeout" = x0; then :

		$as_echo "$as_me: WARNING: Timeout" >&2
		break

fi
	spath=$spath/..
	as_fn_arith $timeout - 1 && timeout=$as_val
done
# while do
)








